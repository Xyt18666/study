<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /*
     解构赋值：  根据结构 进行解构赋值

         数组的解构赋值：

         对象的解构赋值：

     */
    {
      let [a, b, c] = [7, 8, 9];
      console.log(a, b, c);
    }
    {
      let { a, b } = { a: "aaa", b: "bbb" };
      console.log(a, b);
    }
    {
      let obj = {
        p: ["hello", { y: "woride" }],
      };
      let {
        p: [a, { y: b }],
      } = obj;
      console.log(a, b);
    }
    //--------------------------------------------------

    /*
     流程控制语句：

         顺序结构

         单分支：
             if(){}


         双分支：
            if(){}else{}

         多分支:
            if(){}else if{}
            switch(){
                case():
                break
                case():
                break
                default:
                    brdak

            }
        嵌套分支：


     循环语句：

         while()

         do{}while()

         for(初始值;条件;迭代){}

             break  跳出循环
             continue  跳过此次循环



     */

    //------------------------------------------------------------

    /*
     函数：
         定义：
             function fn(){}
             let fn = function(){}

         参数：
             function fn(形参){
                 console.log(...arguments)   不定参数
                 return 返回值
             }
             fn(实参)

         es6新增：

             允许为函数参数设置默认值(函数的参数优先考虑自己的作用域)


             rest参数：
                 把散列参数聚集起来
                 他只能是最后一个参数

             箭头函数：()=>{}

               单参数：小括号可以省略
               单执行语句：{}可以省略

               this的指向：是定义时 所在的对象，而非调用时的对象
               不可以使用 new关键字 构造
               没有 arguments参数 ，可以使用rest参数
               不能使用 yield 命令 ，不能用于Generartor函数



    */
    {
      function fn(a, b = 9) {
        console.log(a + b);
      }
      fn(9);
    }
    {
      let x = 1;
      function fn(x, y = x) {
        console.log(x, y); //undefined undefined
      }
      fn();
    }
    {
      let x = 1;
      function fn(m, y = x) {
        console.log(x, y); //1 1
      }
      fn();
    }
    {
      let x = 1;
      function fn(x = x) {
        console.log(x); //报错   ReferenceError 引用错误
        // 函数内部 参数的声明 用的let
        // let x=x
        // 为啥var 不会报错  因为var有变量提升  var了就是undefined let没有提升 既声明又赋值
      }
      //   fn();
    }

    {
      function fn(a, ...b) {
        console.log(a, [...b]); //rest参数
      }
      fn(1, 2, 3, 4, 4, 5, 5);
    }
    {
      let obj = {
        a: "张三",
        skill: () => {
          console.log(this.a); //window.a
        },
        fn() {
          setTimeout(() => {
            console.log(this.a); //张三
          }, 1000);
        },
      };
      obj.fn();
      obj.skill();
    }
    {
      let Fn = function (name) {
        this.name = name;
      };
      let fn = new Fn("newFnNaem");
      console.log(fn);
    }
    //---------------------------------------------------

  </script>
</html>
