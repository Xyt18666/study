<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /*

    数据类型：
      值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。
      引用数据类型：对象(Object)，obj包括 ：数组(Array)、函数(Function)。

    数据类型的转换：

    字符串的方法：
      charAt()   返回某个下标的值
      charCodeAt()  返回某个下标的unicode
      toLowerCAse()  小写
      toupperCase()  大写
      split()  以指定的 符号 分割成数组
      replace()  替换
      substring()  截取
      slice()   截取
      subustr()  截取
      concat()  拼接成新字符串
      trim()  去除空格
      search()  寻找在字符串中的位置，返回下标，找不到返回 -1
      indexOf()  有无此值
      lasetIndexOf() 返找
      String.formcharCode()   unicode转 字符
      codePointAt()       返回某个下标字符的 unicode值,识别的更广泛
      String.fromCodePoint()       返回某个 字符编码的 字符,识别的更广泛
      includes()        寻找有没有某个值，返回布尔值
      startsWith(值,起始下标)     返回布尔值，表示参数是否在字符串的 开头
      endsWith(值,起始下标)      结尾
      padStart(几位,值)       向前补全字符串
      padEnd()  向后
      repeat(次数)      把某个字符串 重复几次
      matchAll(regexp)  返回一个正则在当前字符串的匹配值


    数组的方法：
        push() ：向后添加
        pop():删除末尾
        shuift(): 向前添加
        unshift(): 删除首个
        reverse():翻转数组
        sort() : 排序的规则是字符串的排序，从首位开始比较unicode值
        cancat():拼接数组
        join():数组拼接成字符串
        slice():截取
        splice(起始,删除,添加):操作数组
        indexOf()  寻找有没有某个值，返回下标，找不到返回 -1
        lastIndexOf() 倒着找

        Array.isArray(): 判断是不是一个 数组
        forEach()：数组的遍历，function回调
        map(): 遍历数组，返回新数组 ，(item,index,arr)=>{}
        filter():遍历，筛选 (item,index,arr)=>{}
        some():遍历，只要有一个符合条件，就返回 true (item,index,arr)=>{}
        every():遍历，只要有一个不符合条件，就返回 false (item,index,arr)=>{}
        reduce():累 /*-+计算
        reduceRight():倒着，累/*-+计算

        es6新增：
        Array.from(): 将伪数组或者可便利对象转为真数组
        Array.of():将散乱参数  转为数组
        fill(填充值,起始下标,结束下标): 使用给定值，填充一个数组，如果填充的值是对象，这几个对象的内从地址指向同一个位置
        find((valie,index,arr)=>{}):用于找出第一个符合条件的数组成员
        findIndex():用于找出第一个符合条件的数组成员的下标
        includes():判断一个数组是否包含一个指定的值，如果是返回 true，否则false
        values():  for of遍历 数组.values()  输出值
        keys():  for of遍历 数组.keys() 输出下标
        entries(): for of遍历 数组.entries() 输出键值
        flat(展开的层数):展开数组，默认展开1层
        flatMap():先执行一次MAp,在展开数组，只能展开一次


    math函数的方法：
        Math.max(): 获取一组数的最大值
        Math.min(): 最小值
        MAth.abs(): 绝对值

        Math.ceil():向上取整
        Math.floor():向下取整
        Math.round():四舍五入
        Math.trunc(): 取整,去除小数点后面的值

        Math.random():随机数
        
        Math.pow(,): 几的几次方
        Math.sqrt(): 平方根
        Math.cbrt(): 立方根
        
        Math.hypot():返回所有参数 平方和 平方根

    正则的断言：
        x(?=y): 匹配x后面为y的x , 先行断言
        (?<=y)x: 匹配X前面为y的x , 后行断言

    map和对象的转换：
        map转obj : Object.fromEntries(map)
        obj转map : for of  Object.keys(obj)遍历obj ,map.set(k,obj[k])

    reflect的方法：

      get(target, propKey, receiver)
      set(target, propKey, value, receiver)
      has(target, propKey)
      deleteProperty(target, propKey)
      ownKeys(target)


    json与字符串互转：
    
      JSON.parse(jsonString) 字符串转化为 JSON
      JSON.stringify(jsObject) JSON 转化为 字符串

    g函数的关键字：yield

    readyState:ajax对象的工作状态值：
      0：请求未初始化
      1：服务器建立连接
      2：请求已接收
      3：请求处理中
      4：请求已完成，且相应已就绪

    status:服务器返回的数字代码（HTTP状态码）代表请求结果：
      常见的状态码： 
          200:操作成功
          304:缓存
          404:Not found 文件未找到
          403:没有权限 
          501:服务器识别错误
      总结：  
          1**：请求消息收到，继续处理         
          2**：操作成功
          3**：完成此请求必须进一步处理（重定向）
          4**：客户端错误
          5**：服务器错误

    跨域的方式：

      jsonp:
        使用 script 的 src 不受同源策略约束，实现跨域


      跨域资源共享(CORS):
        对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，自动增加一个 Origin 字段，用来说明请求来自哪个源。服务器拿到请求之后，在回应时对应地添加Access-Control-Allow-Origin字段，如果 Origin 不在这个字段的范围中，那么浏览器就会将响应拦截。


      Nginx代理跨域:
        同源策略是浏览器的安全策略，不是HTTP协议的一部分，服务器调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不受同源策略的影响，也就不存在跨域问题





    数组排序：
      arr.sort((a, b) => a - b)

      for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - 1 - i; j++) {
          // 相邻元素两两对比，元素交换，大的元素交换到后面
          if (arr[j] > arr[j + 1]) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
          }
        }
      }

      for (let a = 0; a < arr.length; a++) {
        for (let q = a + 1; q < arr.length; q++) {
          console.log(a, q);
          if (arr[a] > arr[q]) {
            [arr[a], arr[q]] = [arr[q], arr[a]];
          }
        }
      }



    h5改变历史记录的函数：
      pushState(data,title,url) 用来保存历史记录的数据，(后两个参数不用写)
      onpopstate 事件获取历史管理 储存的值  e.state 


    
    什么是浅拷贝：拷贝的是栈内的东西，如果是复杂数据类型，只拷贝内存地址


    什么是深拷贝：拷贝 堆中的内容 ，原对象修改后，深拷贝的对象无变化



    如何实现深拷贝：
      一： JSON.parse(JSON.stringify(o))
        function deepCopy(o) {
          return JSON.parse(JSON.stringify(o))
        }
        缺陷：这种拷贝方法不可以拷贝一些特殊的属性（例如正则表达式，undefine，function）

      二： 递归遍历
        function deepCopyTwo(obj) {
            let objClone = Array.isArray(obj) ? [] : {};
            if (obj && typeof obj == 'object') {
                for (const key in obj) {
                    //判断obj子元素是否为对象，如果是，递归复制
                    if (obj[key] && typeof obj[key] === "object") {
                        objClone[key] = deepCopyTwo(obj[key]);
                    } else {
                        //如果不是，简单复制
                        objClone[key] = obj[key];
                    }
                }
            }
            return objClone;
        }

      三：代理法
        function deepClone(obj) {
            if (!isObject(obj)) {
                throw new Error('obj 不是一个对象！')
            }

            let isArray = Array.isArray(obj)
            let cloneObj = isArray ? [...obj] : { ...obj }
            Reflect.ownKeys(cloneObj).forEach(key => {
                cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
            })

            return cloneObj
        }
      
      四：Object.create(prop)
        function deepClone(initalObj, finalObj) {    
          var obj = finalObj || {};    
          for (var i in initalObj) {        
            var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
            if(prop === obj) {            
              continue;
            }        
            if (typeof prop === 'object') {
              obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);
            } else {
              obj[i] = prop;
            }
          }    
          return obj;
        }
      
      五：借用 JQ 的 extend 方法实现深拷贝。
      　　$.extend([deep], target, ...object);
        　　deep 表示深拷贝，Boolean
        　　target 目标对象
        　　 ...object 需要进行合并的对象



    pajax获取数据：

    G函数间隔输出 123：



    */
  </script>
</html>
