<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /*
    proxy:Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

    创建：new Proxy(target,heandler)
    target是要代理的对象；handler是代理操作

    this指向： proxy代理中的 this会指向 proxy


    拦截操作：
    get(target, propKey, receiver)
    拦截对象属性的读取，比如proxy.foo和proxy['foo']。

    set(target, propKey, value, receiver)
    拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。

    has(target, propKey)
    拦截propKey in proxy的操作，以及对象的hasOwnProperty方法，返回一个布尔值。

    deleteProperty(target, propKey)
    拦截delete proxy[propKey]的操作，返回一个布尔值。

    ownKeys(target)
    拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。

    getOwnPropertyDescriptor(target, propKey)
    拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。

    defineProperty(target, propKey, propDesc)
    拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。

    preventExtensions(target)
    拦截Object.preventExtensions(proxy)，返回一个布尔值。

    getPrototypeOf(target)
    拦截Object.getPrototypeOf(proxy)，返回一个对象。

    isExtensible(target)
    拦截Object.isExtensible(proxy)，返回一个布尔值。

    setPrototypeOf(target, proto)
    拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。
    如果目标对象是函数，那么还有两种额外操作可以拦截。

    apply(target, object, args)
    拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。

    construct(target, args)
    拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。


    */
    {
      let pro = new Proxy(
        { a: "aa" },
        {
          get(target, prop) {
            console.log("调用了 pro.a");
            return "aaasss";
          },
          set(target, prop, value, proxy) {
            console.log(target, prop, value, proxy);
            if (prop == "aa") {
              return "qqqq";
            }
          },
          has(target, prop) {
            if (prop == "a") {
              return false;
            }
            return prop in target;
          },
          deleteProperty(target, prop) {
            if (prop === "a") {
              return false;
            }
          },
        }
      );
      console.log(pro.a);
      pro.a = "new A";
      console.log(pro.a);

      console.log("a" in pro);
      delete pro.a;
      console.log(pro);
    }
    //---------------------------------------------------------------
    /*
    Reflect:将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现在，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。

    对象上固有的方法可以直接使用Reflect对象调用

    
    
    
    */
    {
      let obj = { a: 1 };
      Reflect.defineProperty(obj, "name", {
        value: "矫情",
      });
      console.log(obj);
    }
  </script>
</html>
