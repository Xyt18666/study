<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
    <title>Document</title>
  </head>
  <body>
    <ul>
      <li>1</li>
      <li>2</li>
      <li>3</li>
      <li>4</li>
    </ul>
  </body>
  <script>
    /*

            变量：
            var：全局作用域
            let：块级作用域（{}内就是块级作用域），不存在变量提升，不可重复声明
            const：常量，不可改变，不存在变量提升，不可重复声明，
                声明和赋值必须一起写，不可以先声明后赋值,
                const声明的对象，可以改变对象内部的值，因为内存指向的是同一个对象

            什么是块级作用域:{}内就是块级作用域
            什么是变量提升：使用var声明的变量，会变量提升，把变量的声明提升到当前作用域的顶层
            什么是暂时性死区：在定义赋值之前访问变量，变量名存在，但是未赋值

            */
    {
      for (var i = 0; i < $("ul li").length; i++) {
        // $("ul li")
        //   .eq(i)
        //   .click(() => {
        //     console.log(i);
        //   });
        // console.log(i + "var 内");
        //因为i是全局变量，for循环不会等待点击事件，所以，i=4,不能实现循环点击
      }
      //   console.log(i + "var 外");
    }
    {
      for (let i = 0; i < 3; i++) {
        // console.log(i + "let 内");
        $("ul li")
          .eq(i)
          .click(() => {
            console.log(i);
          });
        //因为i 在块级作用域内，所有每次循环绑定的下标是不同的，所以不存在问题
      }
      //   console.log(i + "let 外");
    }
    {
      let a = "a";
      const obj = {
        a,
      };
      obj.b = "b";
      console.log(obj);
    }
    //-----------------------------------------------------------------------------------------------------------------
    /*
        数据类型：
        基本数据类型：
            undefined  ：声明了，但未赋值
            Null: 空对象，占位符
            Boolean： true  false
            Number: 包括 数字 和 NaN
                Number()  : 看整体，如果不能转成数字就是NaN
                parseInt()  :逐个看， 字符串转 整数
                parseFloat() ： 逐个看， 字符串转 小数
                isFinite():  判断一个数在不在数值范围内
                isNaN(): 判断是否为NaN,本该返回一个数值，但是不能正确计算，所以返回NaN


                es6新增：
                    提供了 新的进制写法

                    2进制  (0b):逢2进1
                    8进制 (0o)：逢8进1
                    16进制 (0x) :逢16进1  ,0-9,a-f

                    10进制转任何进制，短除法，除以进制，取余
                    例子： 105 转 8进制
                            105/8
                            13----1
                            13/8
                            1---5
                            1/8
                            0--1
                               151


                    2进制、8按进制转10进制，按权展开求和
                    例子：1101001  转10进制
                          2的6次方   2的5次方   2的3次方    2的0次方
                             64     +    32      +    8     +      1    =105


                    2进制转8进制：每3个值代表一个 8进制，不够时高位补0
                        1 101 001
                        1   5    1


                    2进制转16进制：每4个值代表一个 16进制，不够时高位补0
                      0101 1011 1011
                      4+1  8+2+1 8+2+1
                      5    11     11
                      5    b      b



                    ------------------

                    Number.isInteger()  判断是否为一个整数

                    ** 指数运算符 ，几的几次方






        */

    /*
    运算符：
      算数运算符： + - * / % **
      自增自减运算符： ++ --
      比较运算符：< > <= >= == === != !==
      逻辑运算符：&& ||  !
      赋值运算符：= += -= *= /= %=
      三目运算符：?:


    短路效果：
    && ：第一个为假，赋值第一个，反之第二个
    || : 第一个为真，赋值第一个，反之第二个
    ?? ：这个和 || 很像，但是它不会屏蔽掉 false和 0 和NaN

    */

    {
      console.log(NaN ?? "456");
      console.log(NaN || "456");
      // ?? 这个和 || 很像，但是它不会屏蔽掉 false和 0
    }

    /*
    常用关键字：
    var
    let
    const
    function
    class
    break
    continue
    try
    catch
        for
    in
    of
    while
    do
    this
    new
    return
    null
    NaN
    undefinde
    throw  抛出错误
    delete  删除对象
    case   switch项
    defaule 默认值
    typeof  判断类型
    instanceof  测试一个对象是否为一个类的实例
    yield    generators函数内部的关键字
    awite    等待... ,promis相关
    async      promis相关
    super   class类调用父级
    extends   class 继承
    get     取整器
    set     赋值器
    constructor  构造器
    static  静态方法
    import   导入模块
    exports  导出模块


    */

    /*
    常用检测：
    alert()  弹框
    console.log()  控制台输出内容
    console.dir()  输出结构

    */
    {
      console.log(Number.isInteger(-0)); //true
      console.log(Number.isInteger(+0)); //true
      console.log(Number.isInteger(2.0)); //true
      console.log(Number.isInteger(2)); //true
      console.log(Number.isInteger(-0.52)); //false
      console.log(Number.isInteger(2.5)); //false
      console.log(2 ** 3); //8
    }
    //------------------------------------------------------------------------------------
    /*

            string:
                String() 全局函数
                .toString() 每个对象身上都有这个方法,Null undefined不可以 调用

                .length  长度

                charAt()  返回某个下标的 值
                charCodeAt() 返回某个下标字符的 unicode值
                String.fromCharCode()  返回某个 字符编码的 字符
                indexOf()  寻找有没有某个值，返回下标，找不到返回 -1
                lastIndexOf() 倒着找
                split()  以某个值 分割字符串
                concat() 拼接字符串
                trim()  删除首尾空格
                search()  寻找在字符串中的位置，返回下标，找不到返回 -1
                replace() 替换
                toLowerCase() 转小写
                toUpperCase() 转大写
                substr(起始下标,截取长度)截取，不可颠倒，可为负数
                slice(起始下标,结束下标前)截取，参数不可颠倒，可以为负数
                substring(起始下标,结束下标前)截取，参数可颠倒，不可为负数

                es6新增：
                模板字符串标签函数 ： 例子：String.raw``


                  for of 遍历字符串

                  `` 模板字符串  ${}

                  codePointAt() 返回某个下标字符的 unicode值,识别的更广泛
                  String.fromCodePoint() 返回某个 字符编码的 字符,识别的更广泛
                  includes() 寻找有没有某个值，返回布尔值
                  startsWith(值,起始下标) 返回布尔值，表示参数是否在字符串的 开头
                  endsWith(值,起始下标) 结尾
                  padStart(几位,值) 向前补全字符串
                  padEnd()  向后
                  repeat(次数)  把某个字符串 重复几次
                  String.raw`` 返回一个斜杠都被转义的字符
                  matchAll(regexp)  返回一个正则在当前字符串的匹配值

            Json:
                JSON.parse(jsonString) JSON字符串转化为JSON对象
                JSON.stringify(jsObject) JSON对象转化为JSON字符串
            */
    {
      let str = "qwer123";
      console.log(str.charAt(3)); //r
      console.log(str.charCodeAt(3)); //114
      console.log(String.fromCharCode(114)); //r
      console.log(str.trim()); //qwer123
      console.log(str.search(2)); //5
      console.log(str.substr(4, 1)); //1
      console.log(str.substring(4, 6)); //12
      console.log(str.slice(4, 6)); //12
      console.log(str.codePointAt(3)); //114
      console.log(String.fromCodePoint(114)); //r
      console.log(str.includes(3)); //true
      console.log(str.startsWith(2)); //true
      console.log(str.repeat(2)); //qwer123qwer123
      console.log(String.raw`sdf\/qq`); //sdf\/qq

      const regexp = /[a1B2c3d4]{1,3}/g;
      let str2 = "asd3fzxc1vbqwe2";
      const array = [...str2.matchAll(regexp)];
      console.log(array + "--------------------------------");
    }
    /*

            Symbol("描述")   独一无二的值，不能使用new创建

            1.Symbol函数的参数仅仅是对当前Symbol值的描述，因此相同参数的的Symbol函数的返回值不同
            2.不能与其他类型运算
            3.Symbol可以转换为字符串或者布尔值，但不能转为数字


            用途一：消除魔术字符串
                什么是魔术字符串：就是在代码中多次出现就，与代码强耦合的 数字和字符串为魔术字符串
                解决：使用变量代替，使用Symbol(),生成一个 独一无二的值

            用途二：作为对象的属性名，防止覆盖

            用途三：模拟类的私有方法

            方法：
              Symbol.for()：
                有时候我们希望能够重用一个Symbol值，这时候我们可以使用Symbol.for()，
                该方法能够接受一个参数，然后会在一个“登记表”中搜索使用该参数作为描述的Symbol值是否存在，
                如果存在，则返回已经存在的Symbol值，
                如果不存在就用该参数作为描述生成一个新的Symbol值。
                该方法和Symbol()方法的区别是，该方法会将生成的Symbol登记在全局环境中，而Symbol()不会。

              Symbol.keyFor()：
              可以返回一个已经登记的Symbol值的描述，即key值



            */
    {
      let a = Symbol("aa");
      let b = Symbol("aa");
      console.log(a == b); //false
      //   console.log(a + 1); // Uncaught TypeError: Cannot convert a Symbol value to a number

      console.log(String(a)); //Symbol(aa)
      console.log(b.toString()); //Symbol(aa)
      console.log(Boolean(b)); //true

      const name = Symbol("a");
      const obj = {
        [name]: "ss",
      };
      console.log(obj[name]);
    }

    {
      let s1 = Symbol("a");
      let s2 = Symbol.for("a");
      let s3 = Symbol.for("a");

      console.log(s1 === s2); // false
      console.log(s3 === s2); // true
    }
    {
      let s1 = Symbol.for("foo");

      console.log(Symbol.keyFor(s1), "======"); // "foo"

      let s2 = Symbol("foo2");
      console.log(Symbol.keyFor(s2)); // undefined
    }

    //--------------------------------------------------------------------------------------
    /*
            引用数据类型：

            一种存在堆中，叫做引用数据类型，做等号赋值操作进行的是址传递
            一种存在栈中，叫做基本数据类型，做等号赋值操作进行的是值传递

            引用数据类型：把内存地址指向同一个区域，当原有值改变时，他也会随之改变
            基本数据类型：赋值以后，不再和原有对象相关

            存在堆中：引用数据类型（object、array、function）
            存在栈中：基本数据类型（number、string、boolean、null、unedfined、Symbol（ES6））

            */
    {
      var a = 1;
      var b = a;
      a++;
      console.log(a, b); //2 1

      var str1 = "str1";
      var str2 = str1;
      str1 = "#3333";
      console.log(str1, str2); //#3333 str1
    }
    {
      var arr1 = ["123"];
      var arr2 = arr1;
      console.log(arr1, arr2); //["123"]["123"]
      arr1[0] = "465";
      console.log(arr1, arr2); //["465"]["465"]
    }
    {
      var a = {};
      var b = a;
      a.name = "aname";
      console.log(a, b); //{name: "aname"}
      b.age = 12;
      console.log(a, b); //{name: "aname", age: 12}
      console.log(a == b); //true
    }

    //--------------------------------------------------------------------

    /*
            数组：
            创建的方法：
                构造函数法：new Array()  , 一个数字参数为空多少个位置
                字面量创建：[]

            数组的访问：下标

            数组的遍历：
            for in  (i是下标)
            for of  (i是值)
            forEach()
            es6新方法

            方法：
                push() ：向后添加
                pop():删除末尾
                shuift(): 向前添加
                unshift(): 删除首个
                reverse():翻转数组
                sort() : 排序的规则是字符串的排序，从首位开始比较unicode值
                cancat():拼接数组
                join():数组拼接成字符串
                slice():截取
                splice(起始,删除,添加):操作数组
                indexOf()  寻找有没有某个值，返回下标，找不到返回 -1
                lastIndexOf() 倒着找

                Array.isArray(): 判断是不是一个 数组
                forEach()：数组的遍历，function回调
                map(): 遍历数组，返回新数组 ，(item,index,arr)=>{}
                filter():遍历，筛选 (item,index,arr)=>{}
                some():遍历，只要有一个符合条件，就返回 true (item,index,arr)=>{}
                every():遍历，只要有一个不符合条件，就返回 false (item,index,arr)=>{}
                reduce():累 /*-+计算
                reduceRight():倒着，累/*-+计算

                es6新增：
                Array.from(): 将伪数组或者可便利对象转为真数组
                Array.of():将散乱参数  转为数组
                fill(填充值,起始下标,结束下标): 使用给定值，填充一个数组，如果填充的值是对象，这几个对象的内从地址指向同一个位置
                find((valie,index,arr)=>{}):用于找出第一个符合条件的数组成员
                findIndex():用于找出第一个符合条件的数组成员的下标
                includes():判断一个数组是否包含一个指定的值，如果是返回 true，否则false
                values():  for of遍历 数组.values()  输出值
                keys():  for of遍历 数组.keys() 输出下标
                entries(): for of遍历 数组.entries() 输出键值
                flat(展开的层数):展开数组，默认展开1层
                flatMap():先执行一次MAp,在展开数组，只能展开一次

                ... 拓展运算符

                Array.prototype.copyWithin(从该位置开始替换数据,[从该位置开始读取数据，默认为 0 。如果为负值，表示倒数。,][到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。])
                在数组内部，将指定位置成员复制到其他位置，返回当前数组


            */
    {
      // es6方法
      let b = [4, "4w"];
      let a = "dsf";
      let c = {
        d: "b",
      };
      console.log(Array.of(a, b, c));

      let arr = [1, 8, 3, "6sdf4", 77, "sdf"];
      arr.fill("0", 1, 3);
      console.log(arr);

      for (let key of arr.keys()) {
        console.log(key);
      }
      for (let value of arr.values()) {
        console.log(value);
      }
      for (let [key, value] of arr.entries()) {
        console.log({ key: value });
      }
      arr.forEach(function (item, index, arr) {
        console.log(...arguments);
      });
    }
    {
      //  将 3 号位复制到 0 号位
      let arr = [1, 2, 3, 4, 5];
      arr.copyWithin(0, 3, 4);
      console.log(arr + "--------------------");
    }
    {
      let arr = [1, 5, 9, 2, 4, 8, 2];
      //   arr.sort((a, b) => a - b) //改造sort,完成数字的排序
      arr.sort(function (a, b) {
        //排序的机制是，返回是正数 就是从小到大排列，反之
        // console.log(a, b, a - b, arr);
        return a - b;
      });
    }
    {
      let arr = [8, 1, 4, 5, 68, 4];
      console.log(arr.every((item) => item > 8)); //flase
      console.log(arr.some((item) => item > 8)); //true
      arr.forEach(function (item, index, array) {
        // console.log(...arguments);
      });

      let narr = arr.filter((item, index, arr) => item < 5);
      console.log(narr, arr);
    }
    {
      // 数组去重方法
      let arr = [6, 1, 5, 42, 54, 5, 5, 4];

      // //方法2  Set去重
      // Array.prototype.fn2 = function () {
      //   let newarr2 = new Set(this);
      //   let newArr = [...newarr2];
      //   return newArr;
      // };
      // console.log(arr.fn2());

      //  //方法1  indexOf去重
      //   Array.prototype.fn1 = function () {
      //     let arr = [...this];
      //     // console.log(arr);
      //     var newarr1 = [];
      //     for (var a = 0; a < arr.length; a++) {
      //       if (newarr1.indexOf(arr[a]) == -1) {
      //         newarr1.push(arr[a]);
      //       }
      //     }
      //     return newarr1;
      //   };
      //   console.log(arr.fn1());

      //方法6  includes去重
      // Array.prototype.fn6 = function () {
      //   let arr = [...this];

      //   var newarr1 = [];
      //   for (item of arr) {
      //     if (!newarr1.includes(item)) {
      //       newarr1.push(item);
      //     }
      //   }
      //   return newarr1;
      // };
      // console.log(arr.fn6());

      //方法7  filter去重
      //   Array.prototype.fn7 = function () {
      //     let arr = [...this];
      //     return arr.filter((item, index, arr) => {
      //       return arr.indexOf(item, 0) === index;
      //     });
      //   };
      //   console.log(arr.fn7());

      //方法8  利用对象的属性不重复去重
      // Array.prototype.fn8 = function () {
      //   let arr = [...this];
      //   let obj = {};
      //   let newarr = [];
      //   for (let item of arr) {
      //     if (!obj[item]) {
      //       obj[item] = item;
      //       newarr.push(item);
      //     }
      //   }
      //   return newarr;
      // };
      // console.log(arr.fn8());

      //方法3  排序 判断相邻 去重
      //   Array.prototype.fn3 = function () {
      //     let arr = [...this];
      //     arr.sort((a, b) => a - b);
      //     let newArr = [arr[0]];
      //     // console.log(newArr, arr);
      //     for (var i = 1; i < arr.length; i++) {
      //       console.log(arr[i], newArr[newArr.length - 1]);
      //       if (arr[i] !== newArr[newArr.length - 1]) {
      //         newArr.push(arr[i]);
      //       }
      //     }
      //     return newArr;
      //   };
      //   console.log(arr.fn3());

      //方法4 循环 判断 相同 删除掉
      //   Array.prototype.fn4 = function () {
      //     let len = [...this];
      //     for (let i = 0; i < len.length; i++) {
      //       for (let b = i + 1; b < len.length; b++) {
      //         if (len[i] == len[b]) {
      //           len.splice(b, 1);
      //           b--;
      //         }
      //       }
      //     }
      //     return len;
      //   };
      //   console.log(arr, arr.fn4());
    }
    {
      //数组排序方法

      let arr = [1, 5, 9, 2, 4, 8, 2];
      let fruits = ["Banana", "Orange", "Apple", "Mango"];

      // 方法一  sort()
      // fruits.sort(); //默认升序　　Apple,Banana,Mango,Orange
      // fruits.sort().reverse(); //降序　　Orange,Mango,Banana,Apple
      //   arr.sort((a, b) => a - b) //改造sort,完成数字的 升序, b-a降序

      // 方法二  冒泡
      // for (let i = 0; i < arr.length - 1; i++) {
      //   for (let j = 0; j < arr.length - 1 - i; j++) {
      //     // 相邻元素两两对比，元素交换，大的元素交换到后面
      //     if (arr[j] > arr[j + 1]) {
      //       [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      //     }
      //   }
      // }
      // console.log(arr);

      // 方法三 选择排序
      // for (let a = 0; a < arr.length; a++) {
      //   for (let q = a + 1; q < arr.length; q++) {
      //     console.log(a, q);
      //     if (arr[a] > arr[q]) {
      //       [arr[a], arr[q]] = [arr[q], arr[a]];
      //     }
      //   }
      // }

      //   方法四 快速排序
      // function quickSort(arr) {
      //   if (arr.length <= 1) {
      //     //如果数组只有一个数，就直接返回；
      //     return arr;
      //   }
      //   var num = Math.floor(arr.length / 2); //找到中间数的索引值，如果是浮点数，则向下取整
      //   var newValue = arr.splice(num, 1); //找到中间数的值
      //   var left = [],
      //     right = [];
      //   for (var i = 0; i < arr.length; i++) {
      //     if (arr[i] < newValue) {
      //       left.push(arr[i]); //基准点的左边的数传到左边数组
      //     } else {
      //       right.push(arr[i]); //基准点的右边的数传到右边数组
      //     }
      //   }
      //   return quickSort(left).concat(newValue, quickSort(right)); //递归不断重复比较
      // }
      // console.log(quickSort(arr));
    }
  </script>
</html>
