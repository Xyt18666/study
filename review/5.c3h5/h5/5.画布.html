<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <canvas
      width="800px"
      height="600px"
      style="border: 2px solid #789"
    ></canvas>
    <img
      src="https://dss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4220765120,4182187051&fm=58"
      alt=""
    />
  </body>
  <script>
    let c = document.querySelector("canvas").getContext("2d");

    c.fillStyle = "pink"; //填充色
    c.strokeStyle = "#0f0"; //边框色
    lineWidth = "2";
    lineJoin = "round"; //角的样式 miter默认 round圆角  bevel切角
    c.strokeRect(40, 40, 60, 60); //描边矩形
    c.fillRect(20, 20, 50, 50); //填充矩形
    c.rect(30, 30, 50, 50); //空矩形
    c.stroke(); // 描边
    c.fill(); // 填充

    // c.beginPath(); //开启路径
    // c.strokeStyle = "red"; //设置所需样式
    // c.moveTo(180, 180); //起点
    // c.lineTo(90, 90); //下一个目标点
    // c.stroke(); //绘制
    // c.closePath(); //关闭路径

    // // c.save(); 保存路径 ，用来保存Canvas的状态。save之后，可以调用Canvas的平移、放缩、旋转、错切、裁剪等操作。
    // // c.restore(); 恢复路径 ， 用来恢复Canvas之前保存的状态。防止save后对Canvas执行的操作对后续的绘制有影响。

    // c.beginPath();
    // c.fillStyle = "blue";
    // c.arc(250, 250, 50, 0, 2 * Math.PI, true); //圆形 x,y,r，起始角，结束角，方向
    // c.stroke();
    // c.fill();
    // c.closePath();

    // c.beginPath();
    // c.moveTo(20, 20); // 创建开始点
    // c.lineTo(100, 20); // 创建水平线
    // c.arcTo(150, 20, 150, 70, 20); // 曲线 x,y,x,y,r
    // c.lineTo(150, 120); // 创建垂直线
    // c.stroke(); // 进行绘制
    // c.closePath();

    // c.beginPath();
    // c.shadowOffsetX = 10;
    // c.shadowOffsetY = 10;
    // c.shadowColor = "rgba(100,100,100,0.5)";
    // c.shadowBlur = 7.5;
    // c.fillRect(310, 310, 20, 20); //阴影
    // c.closePath();

    // c.beginPath();
    // var linearGradient1 = c.createLinearGradient(150, 0, 350, 0); //线性渐变 x,y,x,y
    // linearGradient1.addColorStop(0, "rgb(0,   0, 255)"); // 0-1 颜色
    // linearGradient1.addColorStop(0.5, "rgb(0, 255, 0)");
    // linearGradient1.addColorStop(1, "rgb(255, 0, 0)");
    // c.fillStyle = linearGradient1; //把渐变色 赋值给 填充色
    // c.fillRect(150, 10, 200, 100);
    // c.closePath();

    // c.beginPath();
    // var x1 = 100; // 第一个圆圆心的X坐标
    // var y1 = 100; // 第一个圆圆心的Y坐标
    // var r1 = 30; // 第一个圆的半径
    // var x2 = 100; // 第二个圆圆心的X坐标
    // var y2 = 100; // 第二个圆圆心的Y坐标
    // var r2 = 100; // 第二个圆的半径
    // var radialGradient1 = c.createRadialGradient(x1, y1, r1, x2, y2, r2); //径向渐变
    // radialGradient1.addColorStop(0, "rgb(0,   0, 255)");
    // radialGradient1.addColorStop(1, "rgb(0, 255,   0)");
    // c.fillStyle = radialGradient1;
    // c.fillRect(10, 10, 200, 200);
    // c.closePath();

    // c.beginPath();
    // c.font = "36px/12px 微软雅黑"; //文字样式
    // c.textAlign = "center"; //对齐
    // c.fillStyle = "#000"; //颜色
    // c.fillText("omg", 600, 440);
    // c.closePath();

    // c.beginPath(); //绘图
    // // c.drawImage(document.querySelector("img"), 400, 400);//图，x,y
    // // c.drawImage(document.querySelector("img"), 400, 400, 20, 20);//图，x,y,w,h
    // c.drawImage(document.querySelector("img"), 0, 0, 80, 80, 400, 400, 50, 50); //图，开始截取x,开始截取y,截取w,截取h,x,y,w,h
    // c.closePath();

    c.beginPath();
    let imgData = c.getImageData(10, 10, 50, 50); //获取 某区域的 像素 对象 x,y,w,h
    c.putImageData(imgData, 200, 200); // 把像素集合重新输出到画布  imgData ,x,y
    // c.createImageData(50,50)//创建空的 imgData对象
    // ctx.createPattern(img,"repeat")  //重复
    c.closePath();

    c.beginPath(); //转换
    // c.scale(x,y);
    // c.rotate(deg8Math.PI/180);
    // c.translate(x,y);
    // canvas.toDataURL(image/png,1)储存为图片 ，返回base64地址   （类型，质量 0-1）
    c.closePath();

    /*
    c.globalCompositeOperation=xx  合成


    source-over	默认。在目标图像上显示源图像。
    source-atop	在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。
    source-in	在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。
    source-out	在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。
    destination-over	在源图像上方显示目标图像。
    destination-atop	在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。
    destination-in	在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。
    destination-out	在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。
    lighter	显示源图像 + 目标图像。
    copy	显示源图像。忽略目标图像。
    source-over	使用异或操作对源图像与目标图像进行组合。
        
    */
  </script>
</html>
