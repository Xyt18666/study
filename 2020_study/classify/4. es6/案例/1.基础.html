<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /*

    严格模式：
    "ues strict"  es5严格模式
    严格模式下，全局fn的 this不指向window，而是undefined，不允许不使用关键字 声明变量

    自执行函数：  es5
    (function(){})();
    !function(){}();

    
    变量声明：  es6
    let  ：声明变量 ，不存在变量提升，当前作用域有效
    const ：常量 ，只能声明一次，不可修改 ，当前作用域有效，当声明空对象时，对象内的可以修改，因为 const只是指向一个地址(命名最好用大写)


    块级作用域：  es6  完全 代替 自执行函数
    只要是 被 {} 包裹的 ，都是 局部作用域（包括 if for try...）
    

    暂时性死区： 当先输出，后定义变量时
    使用 var ，存在 变量提升，但是无法获取值
    而 let const , 不存在变量提升 ，会报错

    引用数据类型：通过赋值的方式，获取一个值，只是把内存指向同一个地方，当原对象，修改时，引用的也会改变

    谷歌浏览器插件：
    1. 搜索所需插件，下载
    2. 吧后缀改为 zip ,解压到单独文件夹
    3. 设置 拓展 开发者模式 加载以解压的插件


    
    
    
    */

    {
      var arr2 = [];
      for (let a = 0; a < 2; a++) {
        arr2[a] = function () {
          console.log(a); //这里的a是作用域内的a
        };
      }
      //   console.log(a); a无值
      arr2[0](); //0
      arr2[1](); //1
    }
  </script>
</html>
