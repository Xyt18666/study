<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <!-- 
        使用 vuex 配合 本地存储 ，刷新后 数据不丢失

        具体流程：
            商品页面，点击加减，触发事件，修改vuex

            vuex定义 购物车 ：
                const KEY = "gou_wu_che";
                const set = val => {
                    window.localStorage.setItem(KEY, JSON.stringify(val));
                };
                const get = () => {
                    return JSON.parse(window.localStorage.getItem(KEY) || "[]");
                };
            
                购物车 属性 就等于 ：  get()  购物车就是本地存储的内容
            

            修改时，触发函数,
                获取到 vuex 中的 state , 修改copy的数据 ，然后使用 vuex在设置
            
            ps: 获取后的 本地存储 ，修改后， 最后还要 放进本地存储







            
            拷贝数组： slice(0)

            深拷贝：JSON.parse(JSON.stringify(obj))
                ps:
                    1. 如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；
                    2. 如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象
                    3. 如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失
                    4. 如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null
                    5. JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的，  则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；
                    6. 如果对象中存在循环引用的情况也无法正确实现深拷贝
                
            
            原生封装深拷贝函数：
                function deepClone(newObj, obj) {
                    for (var key in obj) {
                        if (obj[key] instanceof Array) {
                            newObj[key] = [];
                            deepClone(newObj[key], obj[key]);
                        } else if (obj[key] instanceof Object) {
                            newObj[key] = {};
                            deepClone(newObj[key], obj[key]);
                        } else {
                            newObj[key] = obj[key];
                        }
                    }
                    return newObj;
                }
                

            简易的对象深拷贝：
                {...obj}








     -->
    </body>
</html>
