<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <!-- 
    题目在知识文档/笔试题

    1. a
    2. b
    3. b
    4. b
    5. a
    6. a
    7. c
    8. b
    9. b
    10. b

    1. 2431
    2. 5次6
    3. 看下面代码
    4. false ，因为是先转为2进制，在进行，双精度浮点数计算方式
    5.  
        1.DNS解析
        2.进行TCP连接
        3.浏览器发送HTTP请求
        4.服务器处理请求
        5.浏览器解析渲染页面 
        6.关闭TCP连接

    6.
        1.原则
            多使用内存，缓存或者其他方法
            减少CPU计算，减少网络请求
            减少IO操作（硬盘读写）

        2.加载资源优化
            静态资源的合并和压缩。
            静态资源缓存（浏览器缓存策略）。
            使用CDN让静态资源加载更快。

        3. 渲染优化
            CSS放head中，JS放body后
            图片懒加载，少使用图片，尽量使用字体图标或者svg
            减少DOM操作，对DOM操作做缓存，多个操作尽量合并在一起执行
            事件节流、防抖
            尽可能的让页面少重载重构，少操作css属性，用class代替
            在js中尽量减少闭包的使用
            少使用嵌套循环
            少使用cookie，使用 h5本地存储
            第一次渲染不加载音频视频 preload=none
            在js封装过程中，尽量做到低耦合高内聚。减少页面的冗余代码
            尽量减少使用递归。避免死递归
            减少网路请求次数


    1.
        常见的状态码： 
          200:操作成功
          304:缓存
          404:Not found 文件未找到
          403:没有权限 
          501:服务器识别错误
        总结：  
          1**：请求消息收到，继续处理         
          2**：操作成功
          3**：完成此请求必须进一步处理（重定向）
          4**：客户端错误
          5**：服务器错误

    2. xhr.abort();

    3.
        target是事件触发的真实元素
        currentTarget是事件绑定的元素

    4. 边框

    5. 创建 挂载 更新 销毁  ， 创建

    6. 看下边代码
       
-----------------------------------------------------------------------------------------------------

1、vue生命周期都有哪些？

    beforeCreate（创建前）
    created（创建后）
    beforeMount（载入前）
    mounted（载入后）
    beforeUpdate（更新前）
    updated（更新后）
    beforeDestroy（销毁前）
    destroyed（销毁后）

    组件缓存钩子：
        ctivated
        deactivated

    路由钩子：
        router.beforeEach((to, from, next) => {})    路由进入前
        router.afterEach((to, form) => {})   路由进入后

        beforeEnter:(to, from, next)=>{}  路由进入前

        beforeRouteEnter(to, from, next) {进入前}  路由进入前
        beforeRouteUpdate(to, from, next) {更新} 路由更新时，但是该组件被复用
        beforeRouteLeave(to, from, next) {离开} 路由离开后

    父子组件生命周期的执行顺序：
        父3子4父1
        父包子

    路由钩子执行顺序：
        全局，独享，组件内


    生命周期和路由钩子的执行顺序：
        先执行路由钩子
        后执行生命周期

    组件缓存钩子与生命周期执行顺序：
        进入顺序：mounted ——> activated
        出去顺序：deactivated ——> beforeCreated
            
               
2、mvvm模式指的是什么？他的优缺点是什么？
    MVC: Model-View-Controller（模型-视图-控制器）
    MVP: Model-View-Presenter
    MVVM: Model-View-ViewModel （模型-视图-视图模型）

    优点：数据驱动视图、组件化、用户体验好
    缺点：不利于seo


3、data为什么在项目中是函数，但在引用中是对象？

    如果是对象会导致：
        对象是引用类型，当同一个组件被多次引用，它们的data都指向同一个内存地址，换句话说，所有组件共享一组data

    如何不共享数据：
        将data设置为一个函数，该函数会返回一个初始数据对象，用function return 其实就相当于申明了新的变量，相互独立



4、v-html 与 v-text有什么区别？
    {{}} 和 v-text 渲染效果一样，只会返回标签的内容 ，不会把标签的效果渲染出
　　v-html 会带着标签效果一样显示,适合对接后台返回富文本内容


5、出现{{}}闪烁的bug怎么解决？

    css：
        [v-cloak] {
            display: none;
        }

    <div v-cloak>
        {{ message }}
    </div>

6、事件修饰符都有哪些？
    .stop           阻止冒泡
    .prevent        阻止默认事件
    .capture        事件代理
    .self           在自己身上触发
    .once
    .native         为组件绑定原生事件
    .sync           
      
7、v-model的修饰都有哪些？
    .lazy并不是实时改变，而是在失去焦点或者按回车时才会更新
    .number将输入转换成Number类型
    .trim可以自动过滤输入首尾的空格

8、v-for的对象渲染
    (value,key,index) in user


9、如何为对象添加属性，删除属性
    原生：
        obj.xx
        obj[xx]
        Object.assgin()

    vue:
        Vue.set(源对象，key，value)
        Vue.delete(源对象，key)

        $set(源对象，key，value)
        $delete(源对象，key)


10、v-if与v-show的区别
    if 不渲染
    show 渲染


11、class与style如何动态绑定
    :xx="{}"  []

12、v-for循环遍历中key值的作用
    唯一标识，不要使用下标，尽量使用 id

13、computed的特点
    缓存，源数据不改变时，他不刷新

14、computed与 watch的区别
    1. 不支持缓存，数据变，直接会触发相应的操作；
    2.watch支持异步；
    3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
    4. 当一个属性发生变化时，需要执行对应的操作；一对多；
    5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，
    　　immediate：组件加载立即触发回调函数执行，
    　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。

        注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。


15、如何实现深度监听
    deep: true

16、如何实现路由监听
    $route

17、组件封装的原则？    
    低耦合，高内聚，复用

18、在定义组的时候，都需要注意哪些？
    命名，文件存放位置，只有一个根

19、组件通信方式都有哪些，分别怎么实现
        $emit
        $event
        props
        $root 
        $parent 
        $children 
        $refs       
                
        eventBus

        $attrs 

        provide
        inject

        状态提升



20、父组件传过来的是对象或数组， 子组件怎么接收？为什么是这样接收
    props:{
        xx:{
            type:Array,
            default() {        
                return {};
            },
        }
    }


            



     -->
    </body>
    <script>
        // for (var i = 1; i <= 5; i++) {
        //     (function (arg) {
        //         // 闭包解决
        //         setTimeout(() => {
        //             console.log(arg);
        //         }, arg * 1000);
        //     })(i);
        // }

        // for (let i = 1; i <= 5; i++) {
        //     // es6解决
        //     setTimeout(() => {
        //         console.log(i);
        //     }, i * 1000);
        // }

        // {
        //     function getSize(n) {
        //         let arr = [1, 2];
        //         for (let a = 0; a < n - 2; a++) {
        //             arr.push(arr[arr.length - 1] + arr[arr.length - 2]);
        //         }
        //         console.log(arr);
        //         console.log(arr[n - 1]);
        //         // 1 2 3 5 8 13 21 34
        //     }

        //     getSize(8);
        // }

        // {
        //     function sum(n) {
        //         if (n === 0) return 0;
        //         if (n === 1) return 1;
        //         if (n === 2) return 2;
        //         return sum(n - 2) + sum(n - 1);
        //     }
        //     sum(8);
        // }

        // {
        //     function getNum(n) {
        //         let n1 = 1;
        //         let n2 = 2;
        //         let n3;
        //         for (var i = 2; i < n; i++) {
        //             n3 = n1 + n2;
        //             n1 = n2;
        //             n2 = n3;
        //         }
        //         console.log(n3);
        //     }
        //     getNum(8);
        // }
    </script>
</html>
