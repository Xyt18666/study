<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <!-- 
    题目在知识文档/笔试题

    1. a
    2. b
    3. b
    4. b
    5. a
    6. a
    7. c
    8. b
    9. b
    10. b

    1. 2431
    2. 5次6
    3. 看下面代码
    4. false ，因为是先转为2进制，在进行，双精度浮点数计算方式
    5.  
        1.DNS解析
        2.进行TCP连接
        3.浏览器发送HTTP请求
        4.服务器处理请求
        5.浏览器解析渲染页面 
        6.关闭TCP连接

    6.
        1.原则
            多使用内存，缓存或者其他方法
            减少CPU计算，减少网络请求
            减少IO操作（硬盘读写）

        2.加载资源优化
            静态资源的合并和压缩。
            静态资源缓存（浏览器缓存策略）。
            使用CDN让静态资源加载更快。

        3. 渲染优化
            CSS放head中，JS放body后
            图片懒加载，少使用图片，尽量使用字体图标或者svg
            减少DOM操作，对DOM操作做缓存，多个操作尽量合并在一起执行
            事件节流、防抖
            尽可能的让页面少重载重构，少操作css属性，用class代替
            在js中尽量减少闭包的使用
            少使用嵌套循环
            少使用cookie，使用 h5本地存储
            第一次渲染不加载音频视频 preload=none
            在js封装过程中，尽量做到低耦合高内聚。减少页面的冗余代码
            尽量减少使用递归。避免死递归
            减少网路请求次数


    1.
        常见的状态码： 
          200:操作成功
          304:缓存
          404:Not found 文件未找到
          403:没有权限 
          501:服务器识别错误
        总结：  
          1**：请求消息收到，继续处理         
          2**：操作成功
          3**：完成此请求必须进一步处理（重定向）
          4**：客户端错误
          5**：服务器错误

    2. xhr.abort();

    3.
        target是事件触发的真实元素
        currentTarget是事件绑定的元素

    4. 边框

    5. 创建 挂载 更新 销毁  ， 创建

    6. 看下边代码
       
-----------------------------------------------------------------------------------------------------

1、vue生命周期都有哪些？

    beforeCreate（创建前）
    created（创建后）
    beforeMount（载入前）
    mounted（载入后）
    beforeUpdate（更新前）
    updated（更新后）
    beforeDestroy（销毁前）
    destroyed（销毁后）

    组件缓存钩子：
        ctivated
        deactivated

    路由钩子：
        router.beforeEach((to, from, next) => {})    路由进入前
        router.afterEach((to, form) => {})   路由进入后

        beforeEnter:(to, from, next)=>{}  路由进入前

        beforeRouteEnter(to, from, next) {进入前}  路由进入前
        beforeRouteUpdate(to, from, next) {更新} 路由更新时，但是该组件被复用
        beforeRouteLeave(to, from, next) {离开} 路由离开后

    父子组件生命周期的执行顺序：
        父3子4父1
        父包子

    路由钩子执行顺序：
        全局，独享，组件内


    生命周期和路由钩子的执行顺序：
        先执行路由钩子
        后执行生命周期

    组件缓存钩子与生命周期执行顺序：
        进入顺序：mounted ——> activated
        出去顺序：deactivated ——> beforeCreated
            
               
2、mvvm模式指的是什么？他的优缺点是什么？
    MVC: Model-View-Controller（模型-视图-控制器）
    MVP: Model-View-Presenter
    MVVM: Model-View-ViewModel （模型-视图-视图模型）

    优点：数据驱动视图、组件化、用户体验好
    缺点：不利于seo


3、data为什么在项目中是函数，但在引用中是对象？

    如果是对象会导致：
        对象是引用类型，当同一个组件被多次引用，它们的data都指向同一个内存地址，换句话说，所有组件共享一组data

    如何不共享数据：
        将data设置为一个函数，该函数会返回一个初始数据对象，用function return 其实就相当于申明了新的变量，相互独立



4、v-html 与 v-text有什么区别？
    {{}} 和 v-text 渲染效果一样，只会返回标签的内容 ，不会把标签的效果渲染出
　　v-html 会带着标签效果一样显示,适合对接后台返回富文本内容


5、出现{{}}闪烁的bug怎么解决？

    css：
        [v-cloak] {
            display: none;
        }

    <div v-cloak>
        {{ message }}
    </div>

6、事件修饰符都有哪些？
    .stop           阻止冒泡
    .prevent        阻止默认事件
    .capture        事件代理
    .self           在自己身上触发
    .once
    .native         为组件绑定原生事件
    .sync           
      
7、v-model的修饰都有哪些？
    .lazy并不是实时改变，而是在失去焦点或者按回车时才会更新
    .number将输入转换成Number类型
    .trim可以自动过滤输入首尾的空格

8、v-for的对象渲染
    (value,key,index) in user


9、如何为对象添加属性，删除属性
    原生：
        obj.xx
        obj[xx]
        Object.assgin()

    vue:
        Vue.set(源对象，key，value)
        Vue.delete(源对象，key)

        $set(源对象，key，value)
        $delete(源对象，key)


10、v-if与v-show的区别
    if 不渲染
    show 渲染


11、class与style如何动态绑定
    :xx="{}"  []

12、v-for循环遍历中key值的作用
    唯一标识，不要使用下标，尽量使用 id

13、computed的特点
    缓存，源数据不改变时，他不刷新

14、computed与 watch的区别
    1. 不支持缓存，数据变，直接会触发相应的操作；
    2.watch支持异步；
    3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
    4. 当一个属性发生变化时，需要执行对应的操作；一对多；
    5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，
    　　immediate：组件加载立即触发回调函数执行，
    　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。

        注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

15、如何实现深度监听
    deep: true

16、如何实现路由监听
    $route

17、组件封装的原则？    
    低耦合，高内聚，复用

18、在定义组的时候，都需要注意哪些？
    命名，文件存放位置，只有一个根

19、组件通信方式都有哪些，分别怎么实现
        $emit
        $event
        props
        $root 
        $parent 
        $children 
        $refs       
                
        eventBus

        $attrs 

        provide
        inject

        状态提升



20、父组件传过来的是对象或数组， 子组件怎么接收？为什么是这样接收
    props:{
        xx:{
            type:Array,
            default() {        
                return {};
            },
        }
    }

-----------------------------------------------------------------------------------------
            

1、slot的作用， 应用场景是什么？
    插槽，其实就相当于占位符。它在组件中给你的HTML模板占了一个位置，让你来传入一些东西。插槽又分为 匿名插槽、具名插槽、作用域插槽


2、如何定义插槽， 和使用插槽？

    定义插槽 ： 在定义组件时 ，在需要插入内容的 地方放置 slot 标签
        <slot name="xx"></slot>

    使用插槽 ： 使用组件时 ， 把需要插入 的 内容写到 组件标签子级（可嵌套元素）
        <template #xx={接收属性}>
            ss
        </template>

3、父子组件更新时，钩子执行的顺序？
    父包子

4、transition 组件实现动画的必备条件是什么？
    包裹以下其中一种：
        条件渲染 (使用 v-if)
        条件展示 (使用 v-show)
        动态组件／router-view
        组件根节点(包裹组件即可)

5、transition 通过类名如何实现动画？
    .v-enter      进入的开始状态
    .v-leave-to   出去结束的 状态
    
    .v-enter-active   过程中的状态
    .v-leave-active   过程中的状态

    .v-enter-to   进入结束
    .v-leave    出去的开始状态

6、transition 如何使用第三方库实现动画？    

    transition( 
        enter-active-class="animate__想要的动画种类"
        leave-active-class="animate__想要的动画种类"
    )
        div(v-show="show" class="animate__animated") 这是添加动画的元素

7、transition-group实现群组动画需要具备的条件？
    添加 key

    transition-group(
        enter-active-class="animate__fadeInRight"
        leave-active-class="animate__fadeOutRight"
    )
        h1(v-show="show" class="animate__animated" :key="1") Animate.css
        h2(v-show="show" class="animate__animated" :key="2") Just-add-water CSS animations


8、父子组件销毁时，钩子执行的顺序？
    父包子

9、路由传参的方式？
    第一种：使用标签 拼接 路径 直接传参
    第二种： push path 拼字符串 ，这里只是传入了 一个值
    第三种：name + params 传参
    第四种： 使用 path + query

10、路由的模式都有哪些？有什么特点？

hash路由和history路由的区别：
    1.hash路由在地址栏URL上有#，而history路由没有会好看一点
    2.我们进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）。
    3.hash路由支持低版本的浏览器，而history路由是HTML5新增的API。
    4.hash的特点在于它虽然出现在了URL中，但是不包括在http请求中，所以对于后端是没有一点影响的，所以改变hash不会重新加载页面，所以这也是单页面应用的必备。
    5.history运用了浏览器的历史记录栈，之前有back,forward,go方法，之后在HTML5中新增了pushState（）和replaceState（）方法（需要特定浏览器的支持），它们提供了对历史记录进行修改的功能，不过在进行修改时，虽然改变了当前的URL，但是浏览器不会马上向后端发送请求。

11、route与 router区别是什么？ 属性分别有哪些？
    route就是一个路由（路由就是url到函数的映射），它可以将url路径和一个函数进行映射。route也可以相当于当前正在跳转的对象，可以从里面获取name，path，params。query等等。

    router是route的实例，相当于一个全局的路由器对象，里面含有许多属性和字对象。

12、路由钩子的执行顺序？
    全局 独享 组件内

13、如何实现路由拦截， 拦截的代码过程？
    router.beforeEach((to, from, next) => {
        if(){
            next();
        }else{
        }
    })

14、路由懒加载的实现方式？
    component: () => import("../views/About.vue")

15、vue单页面应用，首屏加载过慢，或出现白屏怎么解决？   
    1、路由懒加载
    2、骨屏架构加载
    3、首屏采用服务端渲染
    4、使用cdn引入第三方库、静态资源oss减小服务器压力
    5、开启gzip

16、什么是骨架屏？如何实现？
    page-skeleton-webpack-plugin 插件

17、axios的请求方式有？
    　put       对数据全部进行更新
　　  patch     只对更改过的数据进行更新
　　　delete    删除请求(参数可以放在url上也可以和post一样放在请求体中)

18、axios如何实现多个并发请求,2种？
    Promise.all(arr).then(res=>{ })

    axios.all([getUserAccount(), getUserPermissions()])
    .then(axios.spread(function (acct, perms) {
        //acct表示请求返回后数组中的第一条数据，perms表示第二条数据
    }));

19、axios如何进行全局配置？
    axios.defaults.timeout = 30000; // 请求超时时间
    axios.defaults.baseURL = "/api/"; //公共前缀

20、axios如何实现数据拦截， 拦截时都有哪些逻辑处理
    
    axios.interceptors.request.use((data)=>{
        请求拦截器 ，data是请求的数据
        return data;
    })

    axios.interceptors.response.use((data) => {
            响应拦截器，
            return data;
        }
    );

21、数据过滤
    filters:{}
    过滤器的作用：格式化 文本
    使用：{{ val | 过滤器名(可传参) | 可传多个过滤器 }} 过滤了 xx 文本
    过滤器 从左向右 执行

22、如何自定义指令

    directives:{
        指令名:{
            inserted: function (el,binding) {
            },
            bind: function (el, binding, vnode) {
            }
        }
    }

    属性：
        bind(){ 指令 绑定到元素时 调用},   
        inserted(){被绑定元素 插入到 父节点时 },
        update(){所在组件 VNode 更新时调用 },
        componentUpdated(){ 更新结束调用 },
        unbind(){解绑时调用 },

     默认参数：
        el 绑定的元素

        binding 一个对象，包含以下属性
            name：指令名，
            value：绑定值，
            oldValue：绑定的前一个值，
            expression：指令表达式，
            arg：指令参数，
            modifiers：修饰符对象

        vnode vue编译生成的 虚拟dom

23、如何实现mixin？mixin的原则
    mixins:[]

24、keep-alive 组件缓存

    keep-alive的属性 ：
        include - 字符串或正则表达式。只有名称匹配的组件会被缓存，匹配的是组件的name属性。
        exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
        max - 数字。最多可以缓存多少组件实例。


25、vuex
    state :    类似于 data 保存数据
        定义： {}
        使用 ：直接使用

    getters :   以有属性的，衍生 属性 ，对象里是方法，也可以理解为 计算属性  
        定义： son(state){}
        使用 ：直接使用
    
    mutations : 定义修改数据的方法，对象里是方法  , 必须是同步
        定义： setindex(state, val){}
        使用 ：commit :  修改属性值  this.$store.commit("修改数据的方法名",传入的值);


    actions: 定义修改多个数据的方法，对象里是方法 ， 方法内是多个 commit  , 还可以调用 异步 api
        定义：  setni({commit},list){}  第一参数 对象中包含和 store 实例相同的属性和方法
        使用 ：dispatch:  修改一组属性值 this.$store.dispatch("修改组的函数名"，传入的值值)

        
---------------------------------------------------------------------------------------------


1、let  const   var 有什么区别？

    let const:
        同一作用域不可重复声明
        不存变量提升
        独立作用域

    const 赋值保护

2、暂时性死区指的是什么？ 

    暂时性死区指的是在被let或const定义的变量，在该变量被声明之前无法被访问，会报错

3、const定义的变量是否能够修改？
    简单数据类型不可改，复杂数据类型可改，因为 const是赋值保护

4、es6与es5判断是否完全相等的方法是什么？
    ===
    Object.is()

5、es6新增方法 assign， 他在作用是什么？
    用来合并多个对象

6、如何通过assign实现对象拷贝？ 他的拷贝是深拷贝还是浅拷贝？为什么？
    let target = Object.assign({}, source);

    浅拷贝，只拷贝一级，内部如果是复杂数据类型，依旧拷贝引用地址

7、let obj = {a: 'a', b: ''}只获取对象在key, value
    Object.keys(obj)  返回键数组 + for of遍历
    Object.values(obj) 返回值数组 + for of遍历
    Object.entries()  返回键值数组 + for of遍历

8、this指向都有哪些？
    在不同的地方使用有不同的结果
    https://www.cnblogs.com/suixinYB/p/10423453.html

9、箭头函数在this指向是什么？
    箭头函数中的this是通过继承得到的，可以理解成其本身并没有this，是通过谁调用(其父对象来判断的，谁调用它谁就是this)

10、数组解构赋值与对象解构赋值的区别？
    都是按照结构进行解构
    数组要找到指定的下标位置
    对象要选择获取的键名



11、两个数的交换?
    let a = 1; let b = 2; 
    [a,b] = [b,a];

12、写出字符串在方法?
    charAt()   返回某个下标的值
    charCodeAt()  返回某个下标的unicode
    toLowerCAse()  小写
    toupperCase()  大写
    split()  以指定的 符号 分割成数组
    replace()  替换
    substring()  截取
    slice()   截取
    subustr()  截取
    concat()  拼接成新字符串
    trim()  去除空格
    search()  寻找在字符串中的位置，返回下标，找不到返回 -1
    indexOf()  有无此值
    lasetIndexOf() 返找

13、es6中新增方法有哪些？

    String.formcharCode()   unicode转 字符
    codePointAt()       返回某个下标字符的 unicode值,识别的更广泛
    String.fromCodePoint()       返回某个 字符编码的 字符,识别的更广泛
    includes()        寻找有没有某个值，返回布尔值
    startsWith(值,起始下标)     返回布尔值，表示参数是否在字符串的 开头
    endsWith(值,起始下标)      结尾
    padStart(几位,值)       向前补全字符串
    padEnd()  向后
    repeat(次数)      把某个字符串 重复几次
    matchAll(regexp)  返回一个正则在当前字符串的匹配值
    
14、es5中数组方法都有哪些？
    push() ：向后添加
    pop():删除末尾
    shuift(): 向前添加
    unshift(): 删除首个
    reverse():翻转数组
    sort() : 排序的规则是字符串的排序，从首位开始比较unicode值
    cancat():拼接数组
    join():数组拼接成字符串
    slice():截取
    splice(起始,删除,添加):操作数组
    indexOf()  寻找有没有某个值，返回下标，找不到返回 -1
    lastIndexOf() 倒着找

    Array.isArray(): 判断是不是一个 数组
    forEach()：数组的遍历，function回调
    map(): 遍历数组，返回新数组 ，(item,index,arr)=>{}
    filter():遍历，筛选 (item,index,arr)=>{}
    some():遍历，只要有一个符合条件，就返回 true (item,index,arr)=>{}
    every():遍历，只要有一个不符合条件，就返回 false (item,index,arr)=>{}
    reduce():累 /*-+计算
    reduceRight():倒着，累/*-+计算 push() ：向后添加
    pop():删除末尾
    shuift(): 向前添加
    unshift(): 删除首个
    reverse():翻转数组
    sort() : 排序的规则是字符串的排序，从首位开始比较unicode值
    cancat():拼接数组
    join():数组拼接成字符串
    slice():截取
    splice(起始,删除,添加):操作数组
    indexOf()  寻找有没有某个值，返回下标，找不到返回 -1
    lastIndexOf() 倒着找

    Array.isArray(): 判断是不是一个 数组
    forEach()：数组的遍历，function回调
    map(): 遍历数组，返回新数组 ，(item,index,arr)=>{}
    filter():遍历，筛选 (item,index,arr)=>{}
    some():遍历，只要有一个符合条件，就返回 true (item,index,arr)=>{}
    every():遍历，只要有一个不符合条件，就返回 false (item,index,arr)=>{}
    reduce():累 /*-+计算
    reduceRight():倒着，累/*-+计算


15、es6中新增数组方法都有哪些？
    Array.from(): 将伪数组或者可便利对象转为真数组
    Array.of():将散乱参数  转为数组
    fill(填充值,起始下标,结束下标): 使用给定值，填充一个数组，如果填充的值是对象，这几个对象的内从地址指向同一个位置
    find((valie,index,arr)=>{}):用于找出第一个符合条件的数组成员
    findIndex():用于找出第一个符合条件的数组成员的下标
    includes():判断一个数组是否包含一个指定的值，如果是返回 true，否则false
    values():  for of遍历 数组.values()  输出值
    keys():  for of遍历 数组.keys() 输出下标
    entries(): for of遍历 数组.entries() 输出键值
    flat(展开的层数):展开数组，默认展开1层
    flatMap():先执行一次MAp,在展开数组，只能展开一次


16、如何判断一个对象是对象， 如何判断一个数组是数组？
    typeof
    instanceof
    prototype

    Array.isArray()

17、如何将一个对象转换为数组， es5、es6在写法分别是什么？

    [...Object.values(obj)]

    obj.forEach(item=>{
        arr.push(item)
    })



18、如何判断数组是否包含某个给定的值 ？
    includes()

19、for  of  与  for  in  有什么区别？
    for in：
        一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。
        不建议使用for in 遍历数组，因为输出的顺序是不固定的。
        如果迭代的对象的变量值是null或者undefined, for in不执行循环体，建议在使用for in循环之前，先检查该对象的值是不是null或者undefined
    
    for of：
        for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

    for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。
    所以for in更适合遍历对象，不要使用for in遍历数组。

20、filter、map有什么区别       
    过滤、映射

21、 some、 ervery  有什么区别
    所有、只要有一个

22、reduce 的使用语法， 都能实现哪些功能
    arr.reduce((vl, item) => {
        console.log(vl, item); //回调的返回值，数组中的值
        return vl * item;
    }, 初始值);

23、Set 作用
    数组去重


24、Map 在作用
    高级对象，以键值对的形式存储

25、说一下对promise在理解
    Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。

26、async  await说  promise的区别
     async/await是基于Promise的，是进一步的一种优化，它其实就是Generator函数的语法糖，使得异步操作的流程更加清晰



     -->
    </body>
    <script>
        // for (var i = 1; i <= 5; i++) {
        //     (function (arg) {
        //         // 闭包解决
        //         setTimeout(() => {
        //             console.log(arg);
        //         }, arg * 1000);
        //     })(i);
        // }

        // for (let i = 1; i <= 5; i++) {
        //     // es6解决
        //     setTimeout(() => {
        //         console.log(i);
        //     }, i * 1000);
        // }

        // {
        //     function getSize(n) {
        //         let arr = [1, 2];
        //         for (let a = 0; a < n - 2; a++) {
        //             arr.push(arr[arr.length - 1] + arr[arr.length - 2]);
        //         }
        //         console.log(arr);
        //         console.log(arr[n - 1]);
        //         // 1 2 3 5 8 13 21 34
        //     }

        //     getSize(8);
        // }

        // {
        //     function sum(n) {
        //         if (n === 0) return 0;
        //         if (n === 1) return 1;
        //         if (n === 2) return 2;
        //         return sum(n - 2) + sum(n - 1);
        //     }
        //     sum(8);
        // }

        // {
        //     function getNum(n) {
        //         let n1 = 1;
        //         let n2 = 2;
        //         let n3;
        //         for (var i = 2; i < n; i++) {
        //             n3 = n1 + n2;
        //             n1 = n2;
        //             n2 = n3;
        //         }
        //         console.log(n3);
        //     }
        //     getNum(8);
        // }

        // {
        //     let obj = {
        //         a: "aa",
        //         b: () => {
        //             console.log(this);
        //         },
        //         e: function () {
        //             console.log(this);
        //         },
        //         c: {
        //             d: () => {
        //                 console.log(this);
        //             },
        //         },
        //     };
        //     console.log(obj.b());
        //     console.log(obj.c.d());
        //     console.log(obj.e());
        // }

        // {
        //     let a = 1;
        //     let b = 2;
        //     console.log(a, b);

        //     [a, b] = [b, a];
        //     console.log(a, b);
        // }

        // {
        //     let obj = {
        //         a: "aa",
        //         c: "cc",
        //     };
        //     let obj2 = [...Object.values(obj)];

        //     let arr = [];
        //     for (val of Object.values(obj)) {
        //         arr.push(val);
        //     }
        //     console.log(obj, obj2, arr);
        // }
    </script>
</html>
