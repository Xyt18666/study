<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <!-- 
    题目在知识文档/笔试题

    1. a
    2. b
    3. b
    4. b
    5. a
    6. a
    7. c
    8. b
    9. b
    10. b

    1. 2431
    2. 5次6
    3. 看下面代码
    4. false ，因为是先转为2进制，在进行，双精度浮点数计算方式
    5.  
        1.DNS解析
        2.进行TCP连接
        3.浏览器发送HTTP请求
        4.服务器处理请求
        5.浏览器解析渲染页面 
        6.关闭TCP连接

    6.
        1.原则
            多使用内存，缓存或者其他方法
            减少CPU计算，减少网络请求
            减少IO操作（硬盘读写）

        2.加载资源优化
            静态资源的合并和压缩。
            静态资源缓存（浏览器缓存策略）。
            使用CDN让静态资源加载更快。

        3. 渲染优化
            CSS放head中，JS放body后
            图片懒加载，少使用图片，尽量使用字体图标或者svg
            减少DOM操作，对DOM操作做缓存，多个操作尽量合并在一起执行
            事件节流、防抖
            尽可能的让页面少重载重构，少操作css属性，用class代替
            在js中尽量减少闭包的使用
            少使用嵌套循环
            少使用cookie，使用 h5本地存储
            第一次渲染不加载音频视频 preload=none
            在js封装过程中，尽量做到低耦合高内聚。减少页面的冗余代码
            尽量减少使用递归。避免死递归
            减少网路请求次数


    1.
        常见的状态码： 
          200:操作成功
          304:缓存
          404:Not found 文件未找到
          403:没有权限 
          501:服务器识别错误
        总结：  
          1**：请求消息收到，继续处理         
          2**：操作成功
          3**：完成此请求必须进一步处理（重定向）
          4**：客户端错误
          5**：服务器错误

    2. xhr.abort();

    3.
        target是事件触发的真实元素
        currentTarget是事件绑定的元素

    4. 边框

    5. 创建 挂载 更新 销毁  ， 创建

    6. 看下边代码
       
-----------------------------------------------------------------------------------------------------

1、vue生命周期都有哪些？

    beforeCreate（创建前）
    created（创建后）
    beforeMount（载入前）
    mounted（载入后）
    beforeUpdate（更新前）
    updated（更新后）
    beforeDestroy（销毁前）
    destroyed（销毁后）

    组件缓存钩子：
        ctivated
        deactivated

    路由钩子：
        router.beforeEach((to, from, next) => {})    路由进入前
        router.afterEach((to, form) => {})   路由进入后

        beforeEnter:(to, from, next)=>{}  路由进入前

        beforeRouteEnter(to, from, next) {进入前}  路由进入前
        beforeRouteUpdate(to, from, next) {更新} 路由更新时，但是该组件被复用
        beforeRouteLeave(to, from, next) {离开} 路由离开后

    父子组件生命周期的执行顺序：
        父3子4父1
        父包子

    路由钩子执行顺序：
        全局，独享，组件内


    生命周期和路由钩子的执行顺序：
        先执行路由钩子
        后执行生命周期

    组件缓存钩子与生命周期执行顺序：
        进入顺序：mounted ——> activated
        出去顺序：deactivated ——> beforeCreated
            
               
2、mvvm模式指的是什么？他的优缺点是什么？
    MVC: Model-View-Controller（模型-视图-控制器）
    MVP: Model-View-Presenter
    MVVM: Model-View-ViewModel （模型-视图-视图模型）

    优点：数据驱动视图、组件化、用户体验好
    缺点：不利于seo


3、data为什么在项目中是函数，但在引用中是对象？

    如果是对象会导致：
        对象是引用类型，当同一个组件被多次引用，它们的data都指向同一个内存地址，换句话说，所有组件共享一组data

    如何不共享数据：
        将data设置为一个函数，该函数会返回一个初始数据对象，用function return 其实就相当于申明了新的变量，相互独立



4、v-html 与 v-text有什么区别？
    {{}} 和 v-text 渲染效果一样，只会返回标签的内容 ，不会把标签的效果渲染出
　　v-html 会带着标签效果一样显示,适合对接后台返回富文本内容


5、出现{{}}闪烁的bug怎么解决？

    css：
        [v-cloak] {
            display: none;
        }

    <div v-cloak>
        {{ message }}
    </div>

6、事件修饰符都有哪些？
    .stop           阻止冒泡
    .prevent        阻止默认事件
    .capture        事件代理
    .self           在自己身上触发
    .once
    .native         为组件绑定原生事件
    .sync           
      
7、v-model的修饰都有哪些？
    .lazy并不是实时改变，而是在失去焦点或者按回车时才会更新
    .number将输入转换成Number类型
    .trim可以自动过滤输入首尾的空格

8、v-for的对象渲染
    (value,key,index) in user


9、如何为对象添加属性，删除属性
    原生：
        obj.xx
        obj[xx]
        Object.assgin()

    vue:
        Vue.set(源对象，key，value)
        Vue.delete(源对象，key)

        $set(源对象，key，value)
        $delete(源对象，key)


10、v-if与v-show的区别
    if 不渲染
    show 渲染


11、class与style如何动态绑定
    :xx="{}"  []

12、v-for循环遍历中key值的作用
    唯一标识，不要使用下标，尽量使用 id

13、computed的特点
    缓存，源数据不改变时，他不刷新

14、computed与 watch的区别
    1. 不支持缓存，数据变，直接会触发相应的操作；
    2.watch支持异步；
    3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
    4. 当一个属性发生变化时，需要执行对应的操作；一对多；
    5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，
    　　immediate：组件加载立即触发回调函数执行，
    　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。

        注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

15、如何实现深度监听
    deep: true

16、如何实现路由监听
    $route

17、组件封装的原则？    
    低耦合，高内聚，复用

18、在定义组的时候，都需要注意哪些？
    命名，文件存放位置，只有一个根

19、组件通信方式都有哪些，分别怎么实现
        $emit
        $event
        props
        $root 
        $parent 
        $children 
        $refs       
                
        eventBus

        $attrs 

        provide
        inject

        状态提升



20、父组件传过来的是对象或数组， 子组件怎么接收？为什么是这样接收
    props:{
        xx:{
            type:Array,
            default() {        
                return {};
            },
        }
    }

-----------------------------------------------------------------------------------------
            

1、slot的作用， 应用场景是什么？
    插槽，其实就相当于占位符。它在组件中给你的HTML模板占了一个位置，让你来传入一些东西。插槽又分为 匿名插槽、具名插槽、作用域插槽


2、如何定义插槽， 和使用插槽？

    定义插槽 ： 在定义组件时 ，在需要插入内容的 地方放置 slot 标签
        <slot name="xx"></slot>

    使用插槽 ： 使用组件时 ， 把需要插入 的 内容写到 组件标签子级（可嵌套元素）
        <template #xx={接收属性}>
            ss
        </template>

3、父子组件更新时，钩子执行的顺序？
    父包子

4、transition 组件实现动画的必备条件是什么？
    包裹以下其中一种：
        条件渲染 (使用 v-if)
        条件展示 (使用 v-show)
        动态组件／router-view
        组件根节点(包裹组件即可)

5、transition 通过类名如何实现动画？
    .v-enter      进入的开始状态
    .v-leave-to   出去结束的 状态
    
    .v-enter-active   过程中的状态
    .v-leave-active   过程中的状态

    .v-enter-to   进入结束
    .v-leave    出去的开始状态

6、transition 如何使用第三方库实现动画？    

    transition( 
        enter-active-class="animate__想要的动画种类"
        leave-active-class="animate__想要的动画种类"
    )
        div(v-show="show" class="animate__animated") 这是添加动画的元素

7、transition-group实现群组动画需要具备的条件？
    添加 key

    transition-group(
        enter-active-class="animate__fadeInRight"
        leave-active-class="animate__fadeOutRight"
    )
        h1(v-show="show" class="animate__animated" :key="1") Animate.css
        h2(v-show="show" class="animate__animated" :key="2") Just-add-water CSS animations


8、父子组件销毁时，钩子执行的顺序？
    父包子

9、路由传参的方式？
    第一种：使用标签 拼接 路径 直接传参
    第二种： push path 拼字符串 ，这里只是传入了 一个值
    第三种：name + params 传参
    第四种： 使用 path + query

10、路由的模式都有哪些？有什么特点？

hash路由和history路由的区别：
    1.hash路由在地址栏URL上有#，而history路由没有会好看一点
    2.我们进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）。
    3.hash路由支持低版本的浏览器，而history路由是HTML5新增的API。
    4.hash的特点在于它虽然出现在了URL中，但是不包括在http请求中，所以对于后端是没有一点影响的，所以改变hash不会重新加载页面，所以这也是单页面应用的必备。
    5.history运用了浏览器的历史记录栈，之前有back,forward,go方法，之后在HTML5中新增了pushState（）和replaceState（）方法（需要特定浏览器的支持），它们提供了对历史记录进行修改的功能，不过在进行修改时，虽然改变了当前的URL，但是浏览器不会马上向后端发送请求。

11、route与 router区别是什么？ 属性分别有哪些？
    route就是一个路由（路由就是url到函数的映射），它可以将url路径和一个函数进行映射。route也可以相当于当前正在跳转的对象，可以从里面获取name，path，params。query等等。

    router是route的实例，相当于一个全局的路由器对象，里面含有许多属性和字对象。

12、路由钩子的执行顺序？
    全局 独享 组件内

13、如何实现路由拦截， 拦截的代码过程？
    router.beforeEach((to, from, next) => {
        if(){
            next();
        }else{
        }
    })

14、路由懒加载的实现方式？
    component: () => import("../views/About.vue")

15、vue单页面应用，首屏加载过慢，或出现白屏怎么解决？   
    1、路由懒加载
    2、骨屏架构加载
    3、首屏采用服务端渲染
    4、使用cdn引入第三方库、静态资源oss减小服务器压力
    5、开启gzip

16、什么是骨架屏？如何实现？
    page-skeleton-webpack-plugin 插件

17、axios的请求方式有？
    　put       对数据全部进行更新
　　  patch     只对更改过的数据进行更新
　　　delete    删除请求(参数可以放在url上也可以和post一样放在请求体中)

18、axios如何实现多个并发请求,2种？
    Promise.all(arr).then(res=>{ })

    axios.all([getUserAccount(), getUserPermissions()])
    .then(axios.spread(function (acct, perms) {
        //acct表示请求返回后数组中的第一条数据，perms表示第二条数据
    }));

19、axios如何进行全局配置？
    axios.defaults.timeout = 30000; // 请求超时时间
    axios.defaults.baseURL = "/api/"; //公共前缀

20、axios如何实现数据拦截， 拦截时都有哪些逻辑处理
    
    axios.interceptors.request.use((data)=>{
        请求拦截器 ，data是请求的数据
        return data;
    })

    axios.interceptors.response.use((data) => {
            响应拦截器，
            return data;
        }
    );

21、数据过滤
    filters:{}
    过滤器的作用：格式化 文本
    使用：{{ val | 过滤器名(可传参) | 可传多个过滤器 }} 过滤了 xx 文本
    过滤器 从左向右 执行

22、如何自定义指令

    directives:{
        指令名:{
            inserted: function (el,binding) {
            },
            bind: function (el, binding, vnode) {
            }
        }
    }

    属性：
        bind(){ 指令 绑定到元素时 调用},   
        inserted(){被绑定元素 插入到 父节点时 },
        update(){所在组件 VNode 更新时调用 },
        componentUpdated(){ 更新结束调用 },
        unbind(){解绑时调用 },

     默认参数：
        el 绑定的元素

        binding 一个对象，包含以下属性
            name：指令名，
            value：绑定值，
            oldValue：绑定的前一个值，
            expression：指令表达式，
            arg：指令参数，
            modifiers：修饰符对象

        vnode vue编译生成的 虚拟dom

23、如何实现mixin？mixin的原则
    mixins:[]

24、keep-alive 组件缓存

    keep-alive的属性 ：
        include - 字符串或正则表达式。只有名称匹配的组件会被缓存，匹配的是组件的name属性。
        exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
        max - 数字。最多可以缓存多少组件实例。


25、vuex
    state :    类似于 data 保存数据
        定义： {}
        使用 ：直接使用

    getters :   以有属性的，衍生 属性 ，对象里是方法，也可以理解为 计算属性  
        定义： son(state){}
        使用 ：直接使用
    
    mutations : 定义修改数据的方法，对象里是方法  , 必须是同步
        定义： setindex(state, val){}
        使用 ：commit :  修改属性值  this.$store.commit("修改数据的方法名",传入的值);


    actions: 定义修改多个数据的方法，对象里是方法 ， 方法内是多个 commit  , 还可以调用 异步 api
        定义：  setni({commit},list){}  第一参数 对象中包含和 store 实例相同的属性和方法
        使用 ：dispatch:  修改一组属性值 this.$store.dispatch("修改组的函数名"，传入的值值)








     -->
    </body>
    <script>
        // for (var i = 1; i <= 5; i++) {
        //     (function (arg) {
        //         // 闭包解决
        //         setTimeout(() => {
        //             console.log(arg);
        //         }, arg * 1000);
        //     })(i);
        // }

        // for (let i = 1; i <= 5; i++) {
        //     // es6解决
        //     setTimeout(() => {
        //         console.log(i);
        //     }, i * 1000);
        // }

        // {
        //     function getSize(n) {
        //         let arr = [1, 2];
        //         for (let a = 0; a < n - 2; a++) {
        //             arr.push(arr[arr.length - 1] + arr[arr.length - 2]);
        //         }
        //         console.log(arr);
        //         console.log(arr[n - 1]);
        //         // 1 2 3 5 8 13 21 34
        //     }

        //     getSize(8);
        // }

        // {
        //     function sum(n) {
        //         if (n === 0) return 0;
        //         if (n === 1) return 1;
        //         if (n === 2) return 2;
        //         return sum(n - 2) + sum(n - 1);
        //     }
        //     sum(8);
        // }

        // {
        //     function getNum(n) {
        //         let n1 = 1;
        //         let n2 = 2;
        //         let n3;
        //         for (var i = 2; i < n; i++) {
        //             n3 = n1 + n2;
        //             n1 = n2;
        //             n2 = n3;
        //         }
        //         console.log(n3);
        //     }
        //     getNum(8);
        // }
    </script>
</html>
