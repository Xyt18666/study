<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>


</body>
<script>
/*
预先基础学习：


函数：一个使用 function(){} 声明的 方法
构造函数：通过 new 一个函数的调用 生成构造函数
实例对象：通过 new 构造函数创建的  实例
函数对象：函数.某某    
函数调用：xx函数()   的调用

 */


// 同步回调函数：
const arr =[1,3,5];
arr.forEach(item => {//遍历回调，同步回调函数，不会放入队列中，一上来就要执行完
	console.log(item)//先执行
})
console.log("forEach()之后")//后执行



// 异步回调函数:
setTimeout(()=>{//异步回调函数，会放入队列中 将来执行
	console.log('timeout callback()')//后执行
},0)
console.log("timeout之后")//先执行

// 如何判断一个函数是不是异步函数调用：在后面输出一个console.log()  看看谁先输出

// --------------------------------------------

/*

常见的内置错误

1.错误的类型
	Error:所有错误的父类型
		ReferenceError:引用变量不存在
		TypeError:数据类型不正确
		RangeError:数据值不在 其所允许的范围
		SyntaxError:语法错误



2.错误的处理
	捕获错误： try{有可能错的代码}catch(error){error错误对象}
	抛出错误：throw new Error("错误信息xxx")



3.错误对象
	error.message属性：错误相关描述
	error.stack属性：函数调用栈记录信息


*/ 
// --------------------------------------


/*
什么是promise:

1.是js中进行异步编程的新的解决方案。
	旧的是:纯回调的形式。

2.从语法上来说，是一个构造函数，从功能上来说，用来封装异步操作并并可以获取其结果

-------------------------------------

三种状态：
peding    fulfilled   rejectedd
进行        成功         失败

------------------------------------

基本流程：

1. 新建的一个promise对象    new Promise()    pending状态
2. 执行异步操作
3. 分为两种情况，成功或者失败
4. 都会获得一个promise对象  分别是 成 /败状态
5. 调用then()   catch()         
6. 新的promise对象


 */ 
// 创建一个promise对象
const po = new Promise((resolve,reject)=>{//执行器函数
			// 成功的函数,失败的函数
	// 2.执行异步操作
	setTiemout(()=>{
		const time = Date.now()
		if(time % 2 == 0){
			resolve("成功的数据"+time)
		}else{
			reject("失败的数据"+time)
		}
	},1000)

	// 3.1如果成功 调用 resolve
	// 3.2如果失败 调用 reject
})

po.then(value =>{
	console.log("成功的回调",value)
	// 接收得到成功的数据
},reason =>{
	console.log("失败的回调",reason)
	// 接收得到失败的数据
})

// -----------------------------------------

/*
为什么要用promise：
1. 指定回调函数的方式更加灵活：
	旧的：必须在启动异步任务前指定
	promise：启动异步任务 => 返回promise对象 => 给promise对象绑定回调函数(甚至可以在异步结束后)

2.支持链式调用，可以解决回调地狱的问题：
 	什么是回调地狱：回调函数的嵌套调用，外部回调函数异步执行的结果是嵌套回调函数的条件 （不便于阅读/不便于异步处理）

 	解决方案：promise 链式调用

 	最终解决方案： async/await



 */


</script>
</html>