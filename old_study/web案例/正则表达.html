<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
</body>
<script type="text/javascript">
/*
MDN学习网站

正则表达式，也叫格则表达式
主要作用是匹配字符串的

组成：元字符 和 限定符



元字符：
.    除了\n以外的任意字符   "sdfsd234"
[]   表示一个范围   
[0-9] 0-9之的任意一个数字
[1][0-9][0-9]  "100-199"
[a-z] 所有小写字母中，任意一个
[A-Z] 所有大写字母中，任意一个
[a-zA-Z] 所有字母中，任意一个
[0-9a-zA-Z] 所有字母、数字中，任意一个
[] 另一个含义   把正则表达式的意义干掉 [.] 就是一个点
|  或者   [0-9]|[a-z]
()  分组、提升优先级  [0-9]|([a-z])|[A-Z]
()()()  三组
(()(()))   四组


*  前面表达式出现0 到多次
[0-9][a-z]*   ===   "sdfs234"
小写字母中任意一个字，后面要么是没有数字，要么多个数字


+  表示前面至少出现一次到多次
[a-z][9]+  ===  "sdfs9"
前面一个字母，后面最少一个9


?  前面的表达式出现了 0次到一次
[4][a-z]?  === [4123sdf]

另一个含义，阻止贪婪模式
{n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。
{n}?：尽量匹配 n 次。
{n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。
??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。
+?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。
*? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。



限定符:
{0,}   前面表达式出现0 到多次   *
{1,}   表示前面至少出现一次到多次  +
{0,1}  前面的表达式出现了 0次到一次 ?  
{0,5}  更加明确，前面表达式出现的次数  0-5次
{4}    前面表达式出现了 4次


^   表示已什么开头，取反
^[0-9]   以数字开头
[^0-9]   取反 非数字
[^a-z]   非小写字母
[^0-9a-zA-Z]  特殊字符  


$   表示已什么结束

[0-9][a-z]$  必须以小写字母结束

^[0-9][a-z]$   严格模式  "1z"



\d  任意一个数字
\D  任意一个非数字



\s   空白符一个
\S   非空白符


\w    非特殊符号
\W    特殊符号

\b  单词边界

\t  	tab 键

\f      换页

\"     转义引号
\'     转义引号

\u    unicode值

根据字符串来写正则表达式
1，找规律
2，不要追求完美

身份证的正则表达式：
/^[1234568]\d{5}(19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[1-2]\d|3[0-1])\d{3}[0-9X]$/

 
座机电话:   3或者4位 -  8位  
015-45647895
0135-45647895

[0-9]{3,4}[-][0-9]{8}
\d{3,4}[-]\d{8}

qq号码 ：  6-12位
[1-9][0-9]{4,11}


电话号码：

[1][358][0-9][0-9]{8}
第一位，第二位，第3位，0-9 8个


邮箱：

[0-9a-zA-Z_.]+[@][0-9a-zA-Z_.]+([.][a-zA-Z]+){1,2}

 */ 

//创建正则表达式对象

//构造函数创建
// var reg= new RegExp(/^\d{11}$/);

// var bol=reg.test("我的电话是13733678267");

// console.log(bol)


//字面量创建
// var str="我的电话是13733678267"
// var reg=/\d{11}/;
// var bol=reg.test(str)
// console.log(bol)


//简洁版
console.log(/\d{11}/.test("我的电话是13733678267"));




//其他用法
var scr="联通10010,移动10086,电信10000"
//传入一个正则表达式，返回一个数组
var array=scr.match(/\d{5}/g);//g全局
console.log(array)


//提取年月日
var src="2019-10-19"
var array2=src.match(/(\d{4})[-](\d{2})[-](\d{2})/g);
console.log(RegExp.$3)//获取19 提取组


//提取地址信息
var url="xyt199803240613@126.com.cn"
var arr=url.match(/([0-9a-zA-Z_.-]+)([@][0-9a-zA-Z_.-]+)(([.][0-9a-zA-Z]+){2,3})/)
console.log(RegExp.$1,RegExp.$2,RegExp.$3)

//替换 g全局  i不分大小写
var replayo="魑魅魍魉,龙行龘龘"
replayo=replayo.replace(/龙/gi,"*")
console.log(replayo)

//去除空格
var kg="s    dfs  a"
kg=kg.replace(/\s+/gi,"")
console.log(kg)


// 正则表达式传字符串  和macth相同
var shg="联通10010,移动10086,电信10000"
var gers=/\d{5}/g;
var sjgarr=gers.exec(shg)
while(sjgarr!=null){
	console.log(sjgarr[0])
	sjgarr=gers.exec(shg)

}

</script>
</html>